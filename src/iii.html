<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø² Ø§ÙˆØ±Ø¨ÛŒØªØ§Ù„ Ø§ØªÙ…ÛŒ (Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª Ø²ÙˆÙ…)</title>
    <style>
        body { 
            margin: 0; 
            background-color: #1a1a1a; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            font-family: Tahoma, sans-serif; 
            color: #ccc; 
            padding-bottom: 20px;
        }
        canvas { 
            border: 1px solid #444; 
            margin-top: 10px; 
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        h1 { color: #fff; }
        .controls { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 20px; 
            padding: 15px; 
            background-color: #222; 
            border-radius: 8px; 
            margin-top: 10px; 
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5); 
        }
        .control-group { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            min-width: 150px;
        }
        label { margin-bottom: 5px; font-size: 0.9em; }
        input[type="range"] { width: 150px; }
        input[type="color"] { width: 80px; height: 30px; border: none; border-radius: 4px; padding: 2px; }
        #log { margin-top: 10px; color: yellow; font-weight: bold; }
        #ZeffDisplay { color: #8aff8a; font-weight: bold; margin-top: 15px; font-size: 1.1em; }
    </style>
</head>
<body>
    <h1>Ù…Ø¯Ù„ Ø³Ù‡â€ŒØ¨Ø¹Ø¯ÛŒ Ø§ÙˆØ±Ø¨ÛŒØªØ§Ù„â€ŒÙ‡Ø§ (Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª Ø²ÙˆÙ…)</h1>
    <canvas id="glCanvas" width="800" height="600"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <label for="atomicZ">Z (Ø¹Ø¯Ø¯ Ø§ØªÙ…ÛŒ): <span id="atomicZValue">8</span></label>
            <input type="range" id="atomicZ" min="1" max="150" value="8" step="1">
            <span id="elementName">Ø§Ú©Ø³ÛŒÚ˜Ù† (O)</span>
        </div>

        <div class="control-group">
            <label for="n">N (Ø§ØµÙ„ÛŒ): <span id="nValue">2</span></label>
            <input type="range" id="n" min="1" max="8" value="2" step="1">
        </div>
        <div class="control-group">
            <label for="l">L (Ø¢Ø²ÛŒÙ…ÙˆØªØ§Ù„): <span id="lValue">1</span></label>
            <input type="range" id="l" min="0" max="7" value="1" step="1">
        </div>
        <div class="control-group">
            <label for="ml">ML (Ù…ØºÙ†Ø§Ø·ÛŒØ³ÛŒ): <span id="mlValue">0</span></label>
            <input type="range" id="ml" min="-7" max="7" value="0" step="1">
        </div>
        
        <div class="control-group">
            <label for="zoomRange">ğŸ” Ø²ÙˆÙ… (Ø¯ÙˆØ±Ø¨ÛŒÙ† Z): <span id="zoomValue">3.0</span></label>
            <input type="range" id="zoomRange" min="1.0" max="100.0" value="3.0" step="0.1">
        </div>

        <div class="control-group">
            <label for="density">Ú†Ú¯Ø§Ù„ÛŒ (Ù†Ù…Ø§ÛŒØ´): <span id="densityValue">10</span></label>
            <input type="range" id="density" min="1" max="100" value="10" step="1">
        </div>
        <div class="control-group">
            <label for="colorPickerPositive">ğŸ¨ ÙØ§Ø² Ù…Ø«Ø¨Øª ($\Psi > 0$):</label>
            <input type="color" id="colorPickerPositive" value="#FF0000">
        </div>
        <div class="control-group">
            <label for="colorPickerNegative">ğŸ¨ ÙØ§Ø² Ù…Ù†ÙÛŒ ($\Psi < 0$):</label>
            <input type="color" id="colorPickerNegative" value="#0000FF">
        </div>
    </div>
    
    <div id="ZeffDisplay">Zeff (Ø¨Ø§Ø± Ù…Ø¤Ø«Ø± Ù‡Ø³ØªÙ‡): 4.55</div>
    <div id="log"></div>

<script>
// ------------------------------------------------------------------
// 1. JAVASCRIPT LOGIC (WebGl Setup, Controls, Zeff Calculation)
// ------------------------------------------------------------------

const elementNames = {
    // ... (Ø¯ÛŒÚ©Ø´Ù†Ø±ÛŒ Ú©Ø§Ù…Ù„ Ù†Ø§Ù… Ø¹Ù†Ø§ØµØ±) ...
    1: "Ù‡ÛŒØ¯Ø±ÙˆÚ˜Ù† (H)", 2: "Ù‡Ù„ÛŒÙˆÙ… (He)", 3: "Ù„ÛŒØªÛŒÙ… (Li)", 4: "Ø¨Ø±ÛŒÙ„ÛŒÙ… (Be)", 5: "Ø¨ÙˆØ± (B)", 
    6: "Ú©Ø±Ø¨Ù† (C)", 7: "Ù†ÛŒØªØ±ÙˆÚ˜Ù† (N)", 8: "Ø§Ú©Ø³ÛŒÚ˜Ù† (O)", 9: "ÙÙ„ÙˆØ¦ÙˆØ± (F)", 10: "Ù†Ø¦ÙˆÙ† (Ne)",
    11: "Ø³Ø¯ÛŒÙ… (Na)", 12: "Ù…Ù†ÛŒØ²ÛŒÙ… (Mg)", 13: "Ø¢Ù„ÙˆÙ…ÛŒÙ†ÛŒÙˆÙ… (Al)", 14: "Ø³ÛŒÙ„ÛŒØ³ÛŒÙ… (Si)", 15: "ÙØ³ÙØ± (P)",
    16: "Ú¯ÙˆÚ¯Ø±Ø¯ (S)", 17: "Ú©Ù„Ø± (Cl)", 18: "Ø¢Ø±Ú¯ÙˆÙ† (Ar)", 19: "Ù¾ØªØ§Ø³ÛŒÙ… (K)", 20: "Ú©Ù„Ø³ÛŒÙ… (Ca)",
    21: "Ø§Ø³Ú©Ø§Ù†Ø¯ÛŒÙ… (Sc)", 22: "ØªÛŒØªØ§Ù†ÛŒÙˆÙ… (Ti)", 23: "ÙˆØ§Ù†Ø§Ø¯ÛŒÙ… (V)", 24: "Ú©Ø±ÙˆÙ… (Cr)", 25: "Ù…Ù†Ú¯Ù†Ø² (Mn)",
    26: "Ø¢Ù‡Ù† (Fe)", 27: "Ú©Ø¨Ø§Ù„Øª (Co)", 28: "Ù†ÛŒÚ©Ù„ (Ni)", 29: "Ù…Ø³ (Cu)", 30: "Ø±ÙˆÛŒ (Zn)",
    31: "Ú¯Ø§Ù„ÛŒÙ… (Ga)", 32: "Ú˜Ø±Ù…Ø§Ù†ÛŒÙ… (Ge)", 33: "Ø¢Ø±Ø³Ù†ÛŒÚ© (As)", 34: "Ø³Ù„Ù†ÛŒÙ… (Se)", 35: "Ø¨Ø±Ù… (Br)", 36: "Ú©Ø±ÛŒÙ¾ØªÙˆÙ† (Kr)",
    37: "Ø±ÙˆØ¨ÛŒØ¯ÛŒÙ… (Rb)", 38: "Ø§Ø³ØªØ±Ø§Ù†Ø³ÛŒÙ… (Sr)", 39: "Ø§ÛŒØªØ±ÛŒÙ… (Y)", 40: "Ø²ÛŒØ±Ú©ÙˆÙ†ÛŒÙ… (Zr)", 41: "Ù†ÛŒÙˆØ¨ÛŒÙ… (Nb)", 42: "Ù…ÙˆÙ„ÛŒØ¨Ø¯Ù† (Mo)", 
    43: "ØªÚ©Ù†Ø³ÛŒÙˆÙ… (Tc)", 44: "Ø±ÙˆØªÙ†ÛŒÙ… (Ru)", 45: "Ø±ÙˆØ¯ÛŒÙ… (Rh)", 46: "Ù¾Ø§Ù„Ø§Ø¯ÛŒÙ… (Pd)", 47: "Ù†Ù‚Ø±Ù‡ (Ag)", 48: "Ú©Ø§Ø¯Ù…ÛŒÙ… (Cd)", 
    49: "Ø§ÛŒÙ†Ø¯ÛŒÙˆÙ… (In)", 50: "Ù‚Ù„Ø¹ (Sn)", 51: "Ø¢Ù†ØªÛŒâ€ŒÙ…ÙˆØ§Ù† (Sb)", 52: "ØªÙ„ÙˆØ±ÛŒÙ… (Te)", 53: "ÛŒØ¯ (I)", 54: "Ø²Ù†ÙˆÙ† (Xe)",
    55: "Ø³Ø²ÛŒÙ… (Cs)", 56: "Ø¨Ø§Ø±ÛŒÙ… (Ba)", 57: "Ù„Ø§Ù†ØªØ§Ù† (La)", 
    58: "Ø³Ø±ÛŒÙ… (Ce)", 59: "Ù¾Ø±Ø§Ø²Ø¦ÙˆØ¯ÛŒÙ…ÛŒÙ… (Pr)", 60: "Ù†Ø¦ÙˆØ¯ÛŒÙ…ÛŒÙ… (Nd)", 61: "Ù¾Ø±ÙˆÙ…ØªÛŒÙ… (Pm)", 62: "Ø³Ø§Ù…Ø§Ø±ÛŒÙ… (Sm)", 
    63: "ÛŒÙˆØ±ÙˆÙ¾ÛŒÙ… (Eu)", 64: "Ú¯Ø§Ø¯ÙˆÙ„ÛŒÙ†ÛŒÙ… (Gd)", 65: "ØªØ±Ø¨ÛŒÙ… (Tb)", 66: "Ø¯ÛŒØ³Ù¾Ø±ÙˆØ²ÛŒÙ… (Dy)", 67: "Ù‡ÙˆÙ„Ù…ÛŒÙ… (Ho)", 
    68: "Ø§Ø±Ø¨ÛŒÙˆÙ… (Er)", 69: "ØªÙˆÙ„ÛŒÙ… (Tm)", 70: "Ø§ÛŒØªØ±Ø¨ÛŒÙ… (Yb)", 71: "Ù„ÙˆØªØªÛŒÙ… (Lu)",
    72: "Ù‡Ø§ÙÙ†ÛŒÙ… (Hf)", 73: "ØªØ§Ù†ØªØ§Ù„ (Ta)", 74: "ØªÙ†Ú¯Ø³ØªÙ† (W)", 75: "Ø±Ù†ÛŒÙˆÙ… (Re)", 76: "Ø§Ø³Ù…ÛŒÙ… (Os)", 
    77: "Ø§ÛŒØ±ÛŒØ¯ÛŒÙ… (Ir)", 78: "Ù¾Ù„Ø§ØªÛŒÙ† (Pt)", 79: "Ø·Ù„Ø§ (Au)", 80: "Ø¬ÛŒÙˆÙ‡ (Hg)", 81: "ØªØ§Ù„ÛŒÙ… (Tl)", 
    82: "Ø³Ø±Ø¨ (Pb)", 83: "Ø¨ÛŒØ³Ù…ÙˆØª (Bi)", 84: "Ù¾ÙˆÙ„ÙˆÙ†ÛŒÙ… (Po)", 85: "Ø§Ø³ØªØ§ØªÛŒÙ† (At)", 86: "Ø±Ø§Ø¯ÙˆÙ† (Rn)",
    87: "ÙØ±Ø§Ù†Ø³ÛŒÙ… (Fr)", 88: "Ø±Ø§Ø¯ÛŒÙ… (Ra)", 89: "Ø§Ú©ØªÛŒÙ†ÛŒÙ… (Ac)",
    90: "ØªÙˆØ±ÛŒÙ… (Th)", 91: "Ù¾Ø±ÙˆØªØ§Ú©ØªÛŒÙ†ÛŒÙ… (Pa)", 92: "Ø§ÙˆØ±Ø§Ù†ÛŒÙˆÙ… (U)", 93: "Ù†Ù¾ØªÙˆÙ†ÛŒÙˆÙ… (Np)", 94: "Ù¾Ù„ÙˆØªÙˆÙ†ÛŒÙˆÙ… (Pu)", 
    95: "Ø¢Ù…Ø±ÛŒÚ©ÛŒÙˆÙ… (Am)", 96: "Ú©ÙˆØ±ÛŒÙ… (Cm)", 97: "Ø¨Ø±Ú©Ù„ÛŒÙˆÙ… (Bk)", 98: "Ú©Ø§Ù„ÛŒÙØ±Ù†ÛŒÙˆÙ… (Cf)", 99: "Ø§ÛŒÙ†Ø´ØªÛŒÙ†ÛŒÙˆÙ… (Es)", 
    100: "ÙØ±Ù…ÛŒÙˆÙ… (Fm)", 101: "Ù…Ù†Ø¯Ù„ÛŒÙˆÙ… (Md)", 102: "Ù†ÙˆØ¨Ù„ÛŒÙˆÙ… (No)", 103: "Ù„ÙˆØ±Ù†Ø³ÛŒÙ… (Lr)",
    104: "Ø±Ø§Ø¯Ø±ÙÙˆØ±Ø¯ÛŒÙ… (Rf)", 105: "Ø¯ÙˆØ¨Ù†ÛŒÙ… (Db)", 106: "Ø³ÛŒØ¨ÙˆØ±Ú¯ÛŒÙ… (Sg)", 107: "Ø¨ÙˆØ±ÛŒÙ… (Bh)", 108: "Ù‡Ø§Ø³ÛŒÙ… (Hs)", 
    109: "Ù…Ø§ÛŒØªÙ†Ø±ÛŒÙ… (Mt)", 110: "Ø¯Ø§Ø±Ù…Ø´ØªØ§Ø¯ÛŒÙ… (Ds)", 111: "Ø±ÙˆØ¦Ù†ØªÚ¯Ù†ÛŒÙˆÙ… (Rg)", 112: "Ú©ÙˆÙ¾Ø±Ù†ÛŒØ³ÛŒÙ… (Cn)", 
    113: "Ù†ÛŒÙ‡ÙˆÙ†ÛŒÙˆÙ… (Nh)", 114: "ÙÙ„Ø±ÙˆÙˆÛŒÙˆÙ… (Fl)", 115: "Ù…Ø³Ú©ÙˆÙˆÛŒÙ… (Mc)", 116: "Ù„ÛŒÙˆØ±Ù…ÙˆØ±ÛŒÙˆÙ… (Lv)", 117: "ØªÙ†Ø³ÛŒÙ† (Ts)", 
    118: "Ø§ÙˆÚ¯Ø§Ù†Ø³ÙˆÙ† (Og)" 
};

function hexToRgb(hex) {
    const bigint = parseInt(hex.slice(1), 16);
    const r = (bigint >> 16) & 255;
    const g = (bigint >> 8) & 255;
    const b = bigint & 255;
    return [r / 255.0, g / 255.0, b / 255.0];
}

function calculateSlaterZeff(Z, n, l) {
    if (Z === 1) return 1.0;
    if (Z > 120) {
        document.getElementById('log').innerText = `âš ï¸ Z=${Z}: Ù…Ø¯Ù„ ØºÛŒØ± Ù†Ø³Ø¨ÛŒØªÛŒ ÙØ§Ù‚Ø¯ Ø§Ø¹ØªØ¨Ø§Ø± ÙÛŒØ²ÛŒÚ©ÛŒ Ø§Ø³Øª.`;
        return 1.0; 
    } else {
        document.getElementById('log').innerText = "";
    }
    
    let inner_electrons = 0; 
    if (Z <= 2) inner_electrons = 0; 
    else if (Z <= 10) inner_electrons = 2; 
    else if (Z <= 18) inner_electrons = 10; 
    else if (Z <= 36) inner_electrons = 18; 
    else if (Z <= 54) inner_electrons = 36; 
    else if (Z <= 86) inner_electrons = 54; 
    else if (Z <= 118) inner_electrons = 86; 
    
    let valence_electrons = Z - inner_electrons;
    let S_val = 0.0; 
    
    if (n === 1) {
        S_val += (Z - 1) * 0.30;
    } else {
        let core_shells = 0;
        if (n === 3) core_shells = 2; 
        if (n === 4) core_shells = 10; 
        
        let S_core = core_shells * 1.0;
        let S_penultimate = (inner_electrons - core_shells) * 0.85; 

        S_val = S_core + S_penultimate;
        S_val += Math.max(0, valence_electrons - 1) * 0.35;
    }

    let Zeff = Z - S_val;
    return Math.max(1.0, Zeff); 
}

// ------------------------------------------------------------------
// 2. GLSL SHADER CODE (ØªØºÛŒÛŒØ± Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ø²ÙˆÙ…)
// ------------------------------------------------------------------

const vertSrc = `#version 300 es
in vec4 aPosition;
out vec2 vUv;
void main() {
  gl_Position = aPosition;
  vUv = (aPosition.xy + 1.0) * 0.5;
}
`;

const fragSrc = `#version 300 es
precision highp float;
in vec2 vUv;
out vec4 outColor;

uniform float uTime;
uniform vec3 uCam;
uniform float uN;
uniform int uL;
uniform int uML;
uniform float uZeff; 
uniform float uDensity;
uniform vec2 uRes;
uniform vec3 uOrbitalColorPositive; 
uniform vec3 uOrbitalColorNegative; 

// Ø«Ø§Ø¨Øªâ€ŒÙ‡Ø§
const float PI = 3.141592653589793;
const float A0 = 1.0; 
const int MAX_FACT = 30; // Ø­Ø¯Ø§Ú©Ø«Ø± ÙØ§Ú©ØªÙˆØ±ÛŒÙ„ Ù‚Ø§Ø¨Ù„ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø¨Ø±Ø§ÛŒ N=8

// ØªØ§Ø¨Ø¹ ÙØ§Ú©ØªÙˆØ±ÛŒÙ„
float factorialf(int n) {
  if (n < 0 || n > MAX_FACT) return 0.0;
  if (n == 0 || n == 1) return 1.0;
  float f = 1.0; 
  for (int i = 2; i <= n; i++) {
    f *= float(i);
  }
  return f;
}

// ØªØ§Ø¨Ø¹ Ú†Ù†Ø¯Ø¬Ù…Ù„Ù‡â€ŒØ§ÛŒ Ù„Ø§Ú¯Ø± ØªØ¹Ù…ÛŒÙ… ÛŒØ§ÙØªÙ‡ (L_p^a(x)) - **Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡**
float laguerreL(int p, int a, float x) {
  if (p == 0) return 1.0;
  if (p == 1) return 1.0 + float(a) - x;

  float L0 = 1.0; 
  float L1 = 1.0 + float(a) - x; 
  float Ln = 0.0;
  
  // Ø´Ø±ÙˆØ¹ Ø§Ø² k=1 (Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø§Ø³Ø¨Ù‡ L2) ØªØ§ p-1
  for (int k = 1; k < p; k++) { 
    // Ø§Ø² ÙØ±Ù…ÙˆÙ„ Ø¨Ø§Ø²Ú¯Ø´ØªÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…: Ln+1 = ...
    Ln = ((2.0 * float(k) + float(a) + 1.0 - x) * L1 - (float(k) + float(a)) * L0) / (float(k) + 1.0);
    L0 = L1;
    L1 = Ln;
  }
  // L1 Ø§Ú©Ù†ÙˆÙ† Ø¢Ø®Ø±ÛŒÙ† Ù…Ù‚Ø¯Ø§Ø± Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø´Ø¯Ù‡ (Lp) Ø§Ø³Øª.
  return L1;
}

// ØªØ§Ø¨Ø¹ Ú†Ù†Ø¯Ø¬Ù…Ù„Ù‡â€ŒØ§ÛŒ Ù„Ú˜Ø§Ù†Ø¯Ø± ÙˆØ§Ø¨Ø³ØªÙ‡ (P_l^m(cos(theta)))
float assocLegendre(int l, int m, float x) {
  if (abs(m) > l) return 0.0; 
  int absM = abs(m);

  // Ù…Ø­Ø§Ø³Ø¨Ù‡ P_m^m
  float Pmm;
  if (absM == 0) {
      Pmm = 1.0;
  } else {
      // Ø¶Ø±ÛŒØ¨ (-1)^m * (2m-1)!!
      float doubleFact = 1.0;
      for (int i = 1; i <= absM; i++) doubleFact *= (2.0 * float(i) - 1.0);
      Pmm = pow(-1.0, float(absM)) * doubleFact * pow(1.0 - x*x, float(absM)/2.0);
  }
  
  if (l == absM) return Pmm;
  
  // Ù…Ø­Ø§Ø³Ø¨Ù‡ P_{m+1}^m
  float Pmp1 = x * (2.0 * float(absM) + 1.0) * Pmm;
  if (l == absM + 1) return Pmp1;

  // Ù…Ø­Ø§Ø³Ø¨Ù‡ P_l^m Ø¨Ø±Ø§ÛŒ l > m + 1
  float Pk_m2 = Pmm;
  float Pk_m1 = Pmp1;
  float Pk = 0.0;
  
  for (int k = absM + 2; k <= l; k++) {
    Pk = ((2.0 * float(k) - 1.0) * x * Pk_m1 - (float(k) + float(absM) - 1.0) * Pk_m2) / (float(k) - float(absM));
    Pk_m2 = Pk_m1;
    Pk_m1 = Pk;
  }
  
  return Pk;
}

// ØªØ§Ø¨Ø¹ Ù‚Ø³Ù…Øª Ø²Ø§ÙˆÛŒÙ‡â€ŒØ§ÛŒ ÙˆØ§Ù‚Ø¹ÛŒ (Y_l^m)
float realY(int l, int m, float theta, float phi){
  int absM = abs(m);
  float x = cos(theta); 
  
  float norm = sqrt( (2.0*float(l)+1.0)/(4.0*PI) * factorialf(l-absM)/factorialf(l+absM) );
  float Plm = assocLegendre(l, absM, x);
  float Y = norm * Plm;

  if (m > 0) {
    Y *= sqrt(2.0) * cos(float(m) * phi);
  } else if (m < 0) {
    Y *= sqrt(2.0) * sin(float(absM) * phi);
  }
  
  return Y;
}

// ØªØ§Ø¨Ø¹ Ù‚Ø³Ù…Øª Ø´Ø¹Ø§Ø¹ÛŒ Ù‡ÛŒØ¯Ø±ÙˆÚ˜Ù† (R_n,l)
float radialHydrogen(float n, int l, float r, float Zeff){
  float rho = 2.0 * Zeff * r / (n*A0);
  int p = int(n) - l - 1; 
  
  if (p<0 || l >= int(n)) return 0.0;
  
  float n_int = float(int(n)); 
  
  float pref_num = pow(2.0*Zeff/(n_int*A0), 1.5) * sqrt(factorialf(p));
  float pref_den = sqrt(2.0 * n_int * factorialf(int(n_int) + l));
  float pref = pref_num / pref_den;
  
  float L = laguerreL(p, 2*l + 1, rho); 
  
  return pref * pow(r, float(l)) * exp(-rho/2.0) * L;
}

// ØªØ§Ø¨Ø¹ Ú†Ø±Ø®Ø´ Ø¯ÙˆØ±Ø¨ÛŒÙ†
mat3 rot(float rx, float ry, float rz){
  float cx = cos(rx); float sx = sin(rx);
  float cy = cos(ry); float sy = sin(ry);
  float cz = cos(rz); float sz = sin(rz);

  mat3 M = mat3(
    cy*cz, cy*sz, -sy,
    cz*sx*sy - cx*sz, cx*cz + sx*sy*sz, cy*sx,
    cx*cz*sy + sx*sz, -cz*sx + cx*sy*sz, cx*cy
  );
  return M;
}


// ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ø±Ù†Ø¯Ø±
void main(){
  float R_SCALE = max(2.2, uN*uN / uZeff * 1.5); 
  float R = R_SCALE;

  vec2 uv = vUv*2.0 - 1.0;
  // ro.z (ÙØ§ØµÙ„Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø§Ø² Ù…Ø±Ú©Ø²) Ø§Ú©Ù†ÙˆÙ† ØªÙˆØ³Ø· uCam.z Ú©Ù†ØªØ±Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯.
  vec3 ro = vec3(0.0, 0.0, uCam.z); 
  vec3 rd = normalize(vec3(uv, -1.8)); 
  
  mat3 M = rot(uCam.x, uCam.y, 0.0); // uCam.z Ø±Ø§ Ø§Ø² Ú†Ø±Ø®Ø´ Ø­Ø°Ù Ú©Ù†ÛŒØ¯
  ro = M * ro;
  rd = M * rd;

  // Ø¨Ø±Ø®ÙˆØ±Ø¯ Ù¾Ø±ØªÙˆ Ø¨Ø§ Ù…Ú©Ø¹Ø¨ Ù…Ø±Ø¬Ø¹
  vec3 invD = 1.0 / rd;
  vec3 t0s = (vec3(-R) - ro) * invD;
  vec3 t1s = (vec3(+R) - ro) * invD;
  vec3 tsm = min(t0s, t1s);
  vec3 tsM = max(t0s, t1s);
  float t0 = max( max(tsm.x, tsm.y), tsm.z );
  float t1 = min( min(tsM.x, tsM.y), tsM.z );
  if (t1 < max(t0,0.0)) { outColor = vec4(0.04,0.06,0.08,1.0); return; } 

  float t = max(t0, 0.0);
  
  // Ø¯Ùˆ Ø§Ù†Ø¨Ø§Ø´ØªÚ¯Ø± Ú†Ú¯Ø§Ù„ÛŒ Ø¨Ø±Ø§ÛŒ ÙØ§Ø²Ù‡Ø§ÛŒ Ù…Ø«Ø¨Øª Ùˆ Ù…Ù†ÙÛŒ
  float accumPos = 0.0;
  float accumNeg = 0.0;
  
  const int MAX_STEPS = 512;
  int STEPS = int(uRes.x * R_SCALE / 320.0);  
  STEPS = min(STEPS, MAX_STEPS);
  float dt = (t1 - t0) / float(STEPS); 

  // Ray Marching
  for (int i=0;i<STEPS;i++){
    vec3 p = ro + rd * (t + float(i)*dt);
    float r = length(p);
    
    if (r > R * 2.0) continue; 

    float theta = (r > 0.0) ? acos(p.z / r) : 0.0;
    float phi = atan(p.y, p.x);

    float Y = realY(uL, uML, theta, phi);
    float Rn = radialHydrogen(uN, uL, r, uZeff);
    float psi = Rn * Y; // ØªØ§Ø¨Ø¹ Ù…ÙˆØ¬ (Ø¨Ø§ Ø¹Ù„Ø§Ù…Øª)
    float psi2 = psi*psi; // Ú†Ú¯Ø§Ù„ÛŒ Ø§Ø­ØªÙ…Ø§Ù„

    // Ø§Ù†Ø¨Ø§Ø´Øª Ú†Ú¯Ø§Ù„ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ ÙØ§Ø² (Ø¹Ù„Ø§Ù…Øª)
    if (psi >= 0.0) {
        accumPos += psi2 * dt;
    } else {
        accumNeg += psi2 * dt;
    }
  }

  // Ù…Ø­Ø§Ø³Ø¨Ù‡ Ø±Ù†Ú¯ Ù†Ù‡Ø§ÛŒÛŒ
  float tcolPos = sqrt(accumPos * uDensity * 500.0); 
  float tcolNeg = sqrt(accumNeg * uDensity * 500.0); 

  // ØªØ±Ú©ÛŒØ¨ Ø±Ù†Ú¯â€ŒÙ‡Ø§ÛŒ ÙØ§Ø² Ø¨Ø§ Ú†Ú¯Ø§Ù„ÛŒ Ù…Ø±Ø¨ÙˆØ·Ù‡
  vec3 colorPos = uOrbitalColorPositive * tcolPos;
  vec3 colorNeg = uOrbitalColorNegative * tcolNeg;
  
  vec3 baseColor = vec3(0.04, 0.06, 0.08); // Ø±Ù†Ú¯ Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡/ Ù…Ø­ÛŒØ·ÛŒ
  vec3 rgb = baseColor + colorPos + colorNeg;
  
  // Ø§ÙØ²Ø§ÛŒØ´ Ú©Ù„ÛŒ Ø±ÙˆØ´Ù†Ø§ÛŒÛŒ Ùˆ Ú©Ù†ØªØ±Ø§Ø³Øª
  float totalIntensity = tcolPos + tcolNeg;
  rgb = rgb * (1.0 + totalIntensity * 1.5); 
  
  outColor = vec4(rgb, 1.0);
}
`;

// ------------------------------------------------------------------
// 3. JAVASCRIPT LOGIC (WebGL Runtime)
// ------------------------------------------------------------------

const canvas = document.getElementById('glCanvas');
const gl = canvas.getContext('webgl2');

function compileShader(source, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        document.getElementById('log').innerText = `Ø®Ø·Ø§ÛŒ Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„ Shader: ${info}`;
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

if (!gl) { alert("Ù…Ø±ÙˆØ±Ú¯Ø± Ø´Ù…Ø§ Ø§Ø² WebGL 2.0 Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯."); }

const vertexShader = compileShader(vertSrc, gl.VERTEX_SHADER);
const fragmentShader = compileShader(fragSrc, gl.FRAGMENT_SHADER);

if (!vertexShader || !fragmentShader) {
    document.getElementById('log').innerText = "Ø®Ø·Ø§ÛŒ Ø­ÛŒØ§ØªÛŒ: ShaderÙ‡Ø§ Ú©Ø§Ù…Ù¾Ø§ÛŒÙ„ Ù†Ø´Ø¯Ù†Ø¯.";
    throw new Error("Shader compilation failed.");
}

const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);

if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    document.getElementById('log').innerText = `Ø®Ø·Ø§ÛŒ Ù„ÛŒÙ†Ú© Ø¨Ø±Ù†Ø§Ù…Ù‡: ${gl.getProgramInfoLog(program)}`;
    throw new Error("Program linking failed.");
}

gl.useProgram(program);

// ØªÙ†Ø¸ÛŒÙ… Ù‡Ù†Ø¯Ø³Ù‡ (Ú†Ù‡Ø§Ø±Ú¯ÙˆØ´ Ú©Ø§Ù…Ù„ ØµÙØ­Ù‡)
const positionAttributeLocation = gl.getAttribLocation(program, "aPosition");
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
const positions = new Float32Array([-1, -1, -1, 1, 1, -1, 1, 1,]);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
gl.enableVertexAttribArray(positionAttributeLocation);
gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);


// Ù…Ú©Ø§Ù†â€ŒÙ‡Ø§ÛŒ Uniform
const uTimeLoc = gl.getUniformLocation(program, 'uTime');
const uCamLoc = gl.getUniformLocation(program, 'uCam');
const uNLoc = gl.getUniformLocation(program, 'uN');
const uLLoc = gl.getUniformLocation(program, 'uL');
const uMLLoc = gl.getUniformLocation(program, 'uML');
const uZeffLoc = gl.getUniformLocation(program, 'uZeff');
const uDensityLoc = gl.getUniformLocation(program, 'uDensity');
const uResLoc = gl.getUniformLocation(program, 'uRes');
const uOrbitalColorPositiveLoc = gl.getUniformLocation(program, 'uOrbitalColorPositive'); 
const uOrbitalColorNegativeLoc = gl.getUniformLocation(program, 'uOrbitalColorNegative');

// Ù…ØªØºÛŒØ±Ù‡Ø§ÛŒ Ú©Ù†ØªØ±Ù„ÛŒ
let atomicZ = 8; 
let n = 2;
let l = 1;
let ml = 0;
let density = 10.0;
let Zeff = 4.55; 
let orbitalColorPositive = hexToRgb('#FF0000'); 
let orbitalColorNegative = hexToRgb('#0000FF'); 
let camX = 0.0; 
let camY = 0.0; 
let camZ = 3.0; // Ù…Ù‚Ø¯Ø§Ø± Ø§ÙˆÙ„ÛŒÙ‡ Ø²ÙˆÙ… (ÙØ§ØµÙ„Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ†)
let mouseDown = false;
let lastMouseX = 0;
let lastMouseY = 0;

// ØªØ§Ø¨Ø¹ Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø±Ø§Ø¨Ø· Ú©Ø§Ø±Ø¨Ø±ÛŒ (UI)
function updateUI() {
    Zeff = calculateSlaterZeff(atomicZ, n, l);
    document.getElementById('atomicZValue').innerText = atomicZ;
    document.getElementById('elementName').innerText = elementNames[atomicZ] || `Z=${atomicZ}`;
    document.getElementById('ZeffDisplay').innerText = `Zeff (Ø¨Ø§Ø± Ù…Ø¤Ø«Ø± Ù‡Ø³ØªÙ‡): ${Zeff.toFixed(2)}`;
    document.getElementById('nValue').innerText = n;
    document.getElementById('lValue').innerText = l;
    document.getElementById('mlValue').innerText = ml;
    document.getElementById('densityValue').innerText = density.toFixed(1);
    document.getElementById('zoomValue').innerText = camZ.toFixed(1);


    // Ø§Ø¹Ù…Ø§Ù„ Ù…Ø­Ø¯ÙˆØ¯ÛŒØªâ€ŒÙ‡Ø§ÛŒ ÙÛŒØ²ÛŒÚ©ÛŒ (N=8ØŒ L=7)
    const n_max = 8; 
    document.getElementById('n').max = n_max;
    if (n > n_max) { n = n_max; }

    const l_max = n - 1;
    document.getElementById('l').max = l_max;
    
    // ML Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø¬Ø¯ÛŒØ¯ Ø¨Ø± Ø§Ø³Ø§Ø³ L (ØªØ§ 7)
    document.getElementById('ml').max = l;
    document.getElementById('ml').min = -l;
    
    if (l >= n) { l = n - 1; }
    if (Math.abs(ml) > l) { ml = 0; }
    
    document.getElementById('n').value = n;
    document.getElementById('l').value = l;
    document.getElementById('ml').value = ml;
    document.getElementById('density').value = density;
    document.getElementById('zoomRange').value = camZ;
}

// Ú¯ÙˆØ´ Ø¯Ø§Ø¯Ù† Ø¨Ù‡ ÙˆØ±ÙˆØ¯ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ù†ØªØ±Ù„ÛŒ
document.getElementById('atomicZ').addEventListener('input', (e) => { atomicZ = parseInt(e.target.value); updateUI(); });
document.getElementById('n').addEventListener('input', (e) => { n = parseInt(e.target.value); updateUI(); });
document.getElementById('l').addEventListener('input', (e) => { l = parseInt(e.target.value); updateUI(); });
document.getElementById('ml').addEventListener('input', (e) => { ml = parseInt(e.target.value); updateUI(); });
document.getElementById('density').addEventListener('input', (e) => { density = parseFloat(e.target.value); updateUI(); });

// Ø±ÙˆÛŒØ¯Ø§Ø¯ Ù„ØºØ²Ù†Ø¯Ù‡ Ø²ÙˆÙ… (Ø¬Ø¯ÛŒØ¯)
document.getElementById('zoomRange').addEventListener('input', (e) => { 
    camZ = parseFloat(e.target.value);
    updateUI(); 
});

// Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø±Ù†Ú¯
document.getElementById('colorPickerPositive').addEventListener('input', (e) => { orbitalColorPositive = hexToRgb(e.target.value); });
document.getElementById('colorPickerNegative').addEventListener('input', (e) => { orbitalColorNegative = hexToRgb(e.target.value); });

// Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ³ Ø¨Ø±Ø§ÛŒ Ú†Ø±Ø®Ø´
canvas.addEventListener('mousedown', (e) => { 
    mouseDown = true; lastMouseX = e.clientX; lastMouseY = e.clientY;
});
canvas.addEventListener('mouseup', () => { 
    mouseDown = false;
});
canvas.addEventListener('mousemove', (e) => { 
    if (!mouseDown) return;
    const dx = e.clientX - lastMouseX;
    const dy = e.clientY - lastMouseY;
    camY += dx * 0.01; 
    camX += dy * 0.01; 
    lastMouseX = e.clientX; lastMouseY = e.clientY;
});

// Ú©Ù†ØªØ±Ù„â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ³ Ø¨Ø±Ø§ÛŒ Ø²ÙˆÙ… Ø¨Ø§ Scroll (Ø¬Ø¯ÛŒØ¯)
canvas.addEventListener('wheel', (e) => {
    e.preventDefault(); 
    const zoomSpeed = 0.5;
    // deltaY Ù…Ø«Ø¨Øª = Ø§Ø³Ú©Ø±ÙˆÙ„ Ø¨Ù‡ Ù¾Ø§ÛŒÛŒÙ† (Ø²ÙˆÙ… Ø§ÙˆØªØŒ Ø§ÙØ²Ø§ÛŒØ´ camZ)
    // deltaY Ù…Ù†ÙÛŒ = Ø§Ø³Ú©Ø±ÙˆÙ„ Ø¨Ù‡ Ø¨Ø§Ù„Ø§ (Ø²ÙˆÙ… Ø§ÛŒÙ†ØŒ Ú©Ø§Ù‡Ø´ camZ)
    camZ += e.deltaY * 0.01 * zoomSpeed; 
    
    // Ù…Ø­Ø¯ÙˆØ¯ÛŒØª Ø²ÙˆÙ… (Ø¨Ø± Ø§Ø³Ø§Ø³ min/max Ù„ØºØ²Ù†Ø¯Ù‡)
    const minZoom = parseFloat(document.getElementById('zoomRange').min);
    const maxZoom = parseFloat(document.getElementById('zoomRange').max);

    camZ = Math.min(Math.max(camZ, minZoom), maxZoom);
    updateUI();
});


// ØªØ§Ø¨Ø¹ Ø§ØµÙ„ÛŒ Ø±Ù†Ø¯Ø±ÛŒÙ†Ú¯
function draw(time) {
    gl.clearColor(0.04, 0.06, 0.08, 1.0); 
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.uniform1f(uTimeLoc, time * 0.001);
    // Ø§Ø±Ø³Ø§Ù„ uCam: Ø´Ø§Ù…Ù„ Ú†Ø±Ø®Ø´ XØŒ Ú†Ø±Ø®Ø´ Y Ùˆ Ø²ÙˆÙ… Z
    gl.uniform3f(uCamLoc, camX, camY, camZ);
    gl.uniform1f(uNLoc, parseFloat(n));
    gl.uniform1i(uLLoc, l);
    gl.uniform1i(uMLLoc, ml);
    gl.uniform1f(uZeffLoc, Zeff); 
    gl.uniform1f(uDensityLoc, density);
    gl.uniform2f(uResLoc, canvas.width, canvas.height);
    
    // Ø§Ø±Ø³Ø§Ù„ ÛŒÙˆÙ†ÛŒÙØ±Ù…â€ŒÙ‡Ø§ÛŒ Ø±Ù†Ú¯
    gl.uniform3fv(uOrbitalColorPositiveLoc, orbitalColorPositive); 
    gl.uniform3fv(uOrbitalColorNegativeLoc, orbitalColorNegative);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    
    requestAnimationFrame(draw);
}

// Ø´Ø±ÙˆØ¹ Ø±Ù†Ø¯Ø±
updateUI(); 
requestAnimationFrame(draw);
</script>
</body>
</html>